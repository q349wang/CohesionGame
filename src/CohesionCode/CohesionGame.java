/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package CohesionCode;

import static CohesionCode.DrawShapes.obs;
import static CohesionCode.DrawShapes.radians;
import java.awt.*;
import java.awt.event.*;
import java.awt.geom.AffineTransform;
import java.awt.geom.Area;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.Timer;
import java.util.TimerTask;

/**
 * File Name:	CohesionGame Programmer:	Qiuhan (Leo) Wang Date: January 23, 2017
 * Description: A 2-D horizontal scrolller game where the user controlled shape
 * tries to avoid colliding into obstacles with a by matching the colour of the
 * shape and the obstacle. Scores are based off of how many obstacles the
 * individual dodges. The scores will be saved in a text file along with the
 * name of the user if it is one of the top 10 highscores. This is the main
 * class of this game and builds the window which the game runs in
 */
public class CohesionGame extends javax.swing.JFrame implements KeyListener, MouseListener {

    public double speed; // Holds the speed of the falling obstacles

    public static boolean isHighscore = false; // Variable that holds true when player achieves a high score

    public static int currentScore = 0; // Variable to hold the score of the current player

    public Score[] list = new Score[10]; // Array to hold names and scores of top 10 individuals

    public boolean gameOver = false; // Holds true when character hits a shape of a different colour

    DrawShapes gameGUI; // Holds the game JPanel where everything is drawn

    /**
     * Creates new form CohesionGame
     */
    public CohesionGame() {

        initComponents();

        // Initalizes scoreboard array
        readScore();

        bubSort(list); // Sorts array from highest to lowest based on score

        outputScores();

        // Creates game GUI
        gameGUI = new DrawShapes();

        gameGUI.setBackground(Color.WHITE);
        gameGUI.setFocusable(true);
        gameGUI.addKeyListener(this); // Adds keyboard listener for keyboard input

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        gameOverScreen = new javax.swing.JDialog();
        score = new javax.swing.JLabel();
        namePrompt = new javax.swing.JLabel();
        ok = new javax.swing.JButton();
        nameIn = new javax.swing.JTextField();
        gameOverTitle = new javax.swing.JLabel();
        startScreen = new javax.swing.JPanel();
        play = new javax.swing.JButton();
        title = new javax.swing.JLabel();
        scorePrompt = new javax.swing.JLabel();
        scoreScrollPane = new javax.swing.JScrollPane();
        highscores = new javax.swing.JTextArea();
        howTo1 = new javax.swing.JLabel();
        howTo2 = new javax.swing.JLabel();

        score.setFont(new java.awt.Font("Tahoma", 0, 36)); // NOI18N
        score.setText("Score:");

        namePrompt.setText("You scored in the top 10! Enter your name here:");

        ok.setText("OK");
        ok.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                okActionPerformed(evt);
            }
        });

        gameOverTitle.setFont(new java.awt.Font("Tahoma", 0, 36)); // NOI18N
        gameOverTitle.setText("Game Over!");

        javax.swing.GroupLayout gameOverScreenLayout = new javax.swing.GroupLayout(gameOverScreen.getContentPane());
        gameOverScreen.getContentPane().setLayout(gameOverScreenLayout);
        gameOverScreenLayout.setHorizontalGroup(
            gameOverScreenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(gameOverScreenLayout.createSequentialGroup()
                .addGap(22, 22, 22)
                .addGroup(gameOverScreenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(score)
                    .addComponent(gameOverTitle)
                    .addGroup(gameOverScreenLayout.createSequentialGroup()
                        .addComponent(namePrompt)
                        .addGap(18, 18, 18)
                        .addComponent(nameIn, javax.swing.GroupLayout.PREFERRED_SIZE, 96, javax.swing.GroupLayout.PREFERRED_SIZE)))
                .addContainerGap(108, Short.MAX_VALUE))
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, gameOverScreenLayout.createSequentialGroup()
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addComponent(ok)
                .addGap(42, 42, 42))
        );
        gameOverScreenLayout.setVerticalGroup(
            gameOverScreenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(gameOverScreenLayout.createSequentialGroup()
                .addContainerGap(26, Short.MAX_VALUE)
                .addComponent(gameOverTitle)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(score)
                .addGap(25, 25, 25)
                .addGroup(gameOverScreenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(namePrompt)
                    .addComponent(nameIn, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addGap(18, 18, 18)
                .addComponent(ok)
                .addGap(23, 23, 23))
        );

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Cohesion");
        setBackground(new java.awt.Color(255, 255, 255));
        setMaximumSize(new java.awt.Dimension(400, 550));
        setMinimumSize(new java.awt.Dimension(400, 550));
        setResizable(false);

        startScreen.setBackground(new java.awt.Color(255, 255, 255));
        startScreen.setPreferredSize(new java.awt.Dimension(400, 550));

        play.setText("Play");
        play.setAlignmentY(0.0F);
        play.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                playActionPerformed(evt);
            }
        });

        title.setIcon(new javax.swing.ImageIcon(getClass().getResource("/CohesionCode/CohesionTitle.png"))); // NOI18N

        scorePrompt.setFont(new java.awt.Font("Tahoma", 0, 24)); // NOI18N
        scorePrompt.setText("Top Scores:");

        highscores.setEditable(false);
        highscores.setColumns(20);
        highscores.setFont(new java.awt.Font("Tahoma", 0, 14)); // NOI18N
        highscores.setRows(5);
        highscores.setText("1.\n2.\n3.\n4.\n5.\n6.\n7.\n8.\n9.\n10.");
        highscores.setFocusable(false);
        scoreScrollPane.setViewportView(highscores);

        howTo1.setText("Use the Q, W, and E keys to match colours with incoming obstacles!");

        howTo2.setText("Don't get hit by colours that are not the same as you!");

        javax.swing.GroupLayout startScreenLayout = new javax.swing.GroupLayout(startScreen);
        startScreen.setLayout(startScreenLayout);
        startScreenLayout.setHorizontalGroup(
            startScreenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(startScreenLayout.createSequentialGroup()
                .addGap(20, 20, 20)
                .addGroup(startScreenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.CENTER)
                    .addComponent(howTo2)
                    .addComponent(play)
                    .addComponent(scoreScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 197, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(scorePrompt)
                    .addComponent(title, javax.swing.GroupLayout.PREFERRED_SIZE, 316, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(howTo1))
                .addContainerGap(55, Short.MAX_VALUE))
        );
        startScreenLayout.setVerticalGroup(
            startScreenLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(startScreenLayout.createSequentialGroup()
                .addComponent(title, javax.swing.GroupLayout.PREFERRED_SIZE, 223, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(scorePrompt)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(scoreScrollPane, javax.swing.GroupLayout.PREFERRED_SIZE, 193, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(howTo1)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(howTo2, javax.swing.GroupLayout.PREFERRED_SIZE, 14, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(play)
                .addContainerGap(74, Short.MAX_VALUE))
        );

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(startScreen, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(startScreen, javax.swing.GroupLayout.DEFAULT_SIZE, 600, Short.MAX_VALUE)
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    // Outputs scores into textArea
    public final void outputScores() {

        highscores.setText(""); // Clears textArea

        for (int i = 0; i < list.length; i++) { // Adds each score to textArea in neat format

            highscores.append((i + 1) + ". " + list[i].getName() + ": " + list[i].getScore() + "\n");

        }

    }

    // Checks if a character is in contact with a obstacle of a different colour
    public boolean checkColl(Obstacle obstacle) {

        int obsType = obstacle.getType(); // Gets obstacle type

        Area rSplitter = new Area(); // Creates new rotated area for splitter

        Area user = new Area(DrawShapes.character); // Creates new Area for character

        Area[] shapes = new Area[obstacle.numShapes]; // Creates new Area array to hold Areas of obstacle shapes
        Area[] rShapes = new Area[obstacle.numShapes]; // Creates new Area array to hold Areas of rotated obstacle shapes

        AffineTransform af = new AffineTransform(); // Created AffineTransform to match Area with transformations done to the real shapes
        af.rotate(radians, 200, (obstacle.getY() + 150)); // Sets transformation to a rotation of nth radians around middle of the shape counter clockwise (Same as found in DrawShapes)

        Area rUser = user.createTransformedArea(af); // Rotated user area

        // Creates new area for splitter if needed
        if (obsType == 0) { // If obstacle is a SplitCircle, create Area for Rectangle2D splitter

            Area splitter = new Area(obstacle.getShape(0d));

            rSplitter = splitter.createTransformedArea(af); // Rotated splitter area

            user.subtract(rSplitter); // Subtract splitter from user area

        } else if (obsType == 3) { // If obstacle is a TriPie, create Area for Arc2D splitter

            Area splitter = new Area(obstacle.getShape(-1, 0));

            rSplitter = splitter.createTransformedArea(af); // Rotated splitter area

            user.subtract(rSplitter); // Subtract splitter from user area

        }

        if (user.isEmpty()) { // Checks if user is completely in splitter (if so, returns false for collision

            return false;

        } else {

            for (int i = 0; i < shapes.length; i++) { // Initalizes shapes array

                shapes[i] = new Area();

            }

            for (int i = 0; i < shapes.length; i++) { // Checks for intersection between user and shapes

                user.reset(); // Resets user

                user.add(new Area(DrawShapes.character)); // Adds new character area to user

                if (obsType == 0) { // If obstacle is a SplitCircle
                    
                    user.subtract(rSplitter); // Subtract splitter from user area

                } else if (obsType == 3) { // If obstacle is a TriPie

                    user.subtract(rSplitter); // Subtract splitter from user area

                }

                shapes[i].reset(); // Resets shape at i

                // Assigns Areas of the obstacle shapes to each element of the shapes array
                if (obsType == 2) { // If obstacle is TriRect, use Rectangle2D getShape

                    double temp = (double) i; // Converts i to a double

                    shapes[i] = new Area(obstacle.getShape(temp));

                } else { // Else use Arc2D getShape

                    shapes[i] = new Area(obstacle.getShape(i, 0));

                }

                rShapes[i] = shapes[i].createTransformedArea(af);  // Rotated shape area

                if (obsType == 2) { // If using stationary TriRect, do not used rotated shape area

                    user.intersect(shapes[i]);  // Reveal any parts that intersect between user Area and shape[i] Area

                } else {

                    user.intersect(rShapes[i]); // Reveal any parts that intersect between user Area and rShape[i] Area

                }

                if (!user.isEmpty() && !(DrawShapes.colour.equals(obstacle.getCol(i)))) { // Returns true if intersecting with a shape of a differnt colour

                    return true;

                }

            }

        }

        return false;
    }

    private void playActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_playActionPerformed

        gameOverScreen.setVisible(false); // Hides game over screen

        setContentPane(gameGUI); // Changes start screen to game screen
        pack();

        gameGUI.requestFocus(); // Focuses on gameGUI so keyboard events will be registered
        gameGUI.repaint();

        startGame();

    }//GEN-LAST:event_playActionPerformed

    // When ok button is presed, close gameOverScreen, save score, and enable play button

    private void okActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_okActionPerformed

        if (isHighscore) { // If it is a highscore, save it onto the list array and text file

            list[9].setName(nameIn.getText());
            list[9].setScore(currentScore);

            bubSort(list);

            outputScores();
            writeScore();

        }

        play.setEnabled(true); // Enable play button

        gameOverScreen.setVisible(false); // Close game over screen

    }//GEN-LAST:event_okActionPerformed

    public final void bubSort(Score list[]) { // Function to sort a list of Score objects using bubble sort

        boolean swap = true; // Variable to see if a swap of variables occured or not

        int bottom = list.length - 1; // 

        while (swap) {

            swap = false; // Swap is not occuring

            for (int i = 0; i < bottom; i++) {

                if (list[i].getScore() < list[i + 1].getScore()) { // If the score at i is greater than the one at i + 1

                    swap = true; // Swap occurs

                    // Swaps the two values
                    Score temp = list[i];
                    list[i] = list[i + 1];
                    list[i + 1] = temp;

                }

            }

            bottom--; // Reduce bottom by 1

        }

    }

    public final void writeScore() { // Writes scores in score list to text file

        try {
            PrintWriter writer = new PrintWriter("src/CohesionCode/Scores.txt", "UTF-8"); // Creates a new PrintWriter

            for (Score i : list) { // Writes scores for every individual

                writer.println(i.getRank() + ":" + i.getName() + ":" + i.getScore());

            }

            writer.close();
        } catch (IOException e) {

            System.out.println(e);

        }
    }

    public final void readScore() { // Reads scores from text file

        // FileReaders for Score file
        FileReader scoreFile = null;

        // Streams to read Score file
        BufferedReader scoreInput = null;

        try { // Tries to create two FileReaders for EmployeeInfo and PayrollInfor files

            scoreFile = new FileReader("src/CohesionCode/Scores.txt"); // Creates new FileReader for EmployeeInfo
            scoreInput = new BufferedReader(scoreFile); // Creates new BufferedReader for employee

        } catch (FileNotFoundException e) {

            System.out.println("File not found"); // Output error message if file is not found

        }

        try { // Tries to read from file

            for (int i = 0; i < list.length; i++) { // Initalizes the objects in the list array with information from the Score file

                String input[] = scoreInput.readLine().split(":");  // Splits the line into each respective variable (rank, name and then score)

                list[i] = new Score(Integer.parseInt(input[0]), input[1], Integer.parseInt(input[2]));

            }

            // Closes file stream
            scoreInput.close();

        } catch (IOException e) {

            System.out.println("Input/Output error"); // If there is an IO error output error message

        }

    }

    // Method which executes game over protocols (checking if score is high score, changing gameGUI back to start screen, displaying game over popup dialogue)
    public void initGameOver() {

        score.setText("Score: " + Integer.toString(currentScore)); // Outputs score

        if (currentScore > list[9].getScore()) { // If the player's score was higher than the lowest score on the high scores, ask player to input name to put on scoreboard

            namePrompt.setVisible(true);
            nameIn.setVisible(true);

            isHighscore = true; // Highscore was achieved

        } else { // Otherwise, hide this textbox and prompt

            namePrompt.setVisible(false);
            nameIn.setVisible(false);

            isHighscore = false; // Highscore was not achieved
        }

        play.setEnabled(false); // Disable play button so people will have to click ok button

        gameOverScreen.setVisible(true);
        gameOverScreen.pack();
        setContentPane(startScreen);
        pack();
        if (currentScore > list[9].getScore()) { // If the player's score was higher than the lowest score on the high scores, ask player to input name to put on scoreboard

            namePrompt.setVisible(true);
            nameIn.setVisible(true);

        } else { // Otherwise, hide this textbox and prompt

            namePrompt.setVisible(false);
            nameIn.setVisible(false);

        }

    }

    // Clears the game screen and sets up for a new game
    public void startGame() {

        currentScore = 0; // Sets current score to 0

        obs.clear(); // Clears obstacle array

        gameOver = false; // Sets game to be not over

        gameGUI.repaint(); // Updates screen

        obs.add(new QuadCircle(50, -800, 4)); // Adds first obstacle (TriPie) to the course

        DrawShapes.setPoints(180, 520); // Creates a Polygon character

        speed = 1; // How fast the obstacle moves down

        // Creates timer to schedule periodically repeated taskes
        Timer timer;
        timer = new Timer();

// TimerTask to increase speed of the falling obstacles
        TimerTask speedUp = new TimerTask() {
            @Override
            public void run() {

                speed = speed * 1.25; // Increase speed by 25%

            }

        };

        // TimerTask to rotate the obstacle
        TimerTask rotateObs = new TimerTask() {
            @Override
            public void run() {
                DrawShapes.radians += 0.01; // Increases rotation by 0.5 degrees

                if (DrawShapes.radians >= (2 * Math.PI)) { // Resets rotation to 0

                    DrawShapes.radians = 0;

                }

                gameOver = checkColl(obs.get(0)); // Checks if user has collided it an obstacle of different colour

            }

        };

        // TimerTask to drop the obstacles down
        TimerTask dropObs = new TimerTask() {
            @Override
            public void run() {

                for (int i = 0; i < obs.size(); i++) { // Repeats for every obstacle

                    double y = obs.get(i).getY(); // Gets current y value

                    obs.get(i).setY(y + speed); // Adds 1 to y value

                    if (y > 600) { // Removes object from ArrayList

                        obs.remove(i);

                        currentScore++; // Increase the current score by 1

                    }

                    if (obs.get(0).getY() >= 200) {

                        gameOver = checkColl(obs.get(0)); // Checks if user has collided it an obstacle of different colour

                    }

                    if (gameOver) {

                        timer.cancel();
                        timer.purge();

                        initGameOver();

                    }

                }

                //DrawShapes.radians += 0.01; // Increases rotation by 0.5 degrees
                if (DrawShapes.radians >= (2 * Math.PI)) { // Resets rotation to 0

                    DrawShapes.radians = 0;

                }

                if (obs.get(obs.size() - 1).getY() >= 200) { // If last obstacle in array is at or greater than  200 on the y coordinate add another obstacle to the ArrayList at -300 (just before it appears on screen)

                    addObs();

                }

                gameGUI.repaint(); // Updates display

            }
        };

        timer.schedule(dropObs, 0, 10); // Start the timer to drop the obstacle every 10 milliseconds

        timer.schedule(rotateObs, 0, 10); // Start the timer to rotate the obstacle every 10 milliseconds

        timer.schedule(speedUp, 0, 10000); // Speed up every 10 seconds
    }

    // Adds random obstacles to the queue ArrayList
    public final void addObs() {

        int random = (int) Math.ceil(Math.random() * 4); // Finds a random number

        switch (random) { // Adds a random obstacle type to queue based on number

            case 1:

                obs.add(new SplitCircle(50, -300, 2));

                break;

            case 2:

                obs.add(new QuadCircle(50, -300, 4));

                break;

            case 3:

                obs.add(new TriRect(50, -300, 3));

                break;

            case 4:

                obs.add(new TriPie(50, -300, 3));

                break;

        }
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(CohesionGame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(CohesionGame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(CohesionGame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(CohesionGame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new CohesionGame().setVisible(true);
            }
        });
    }

    @Override
    public void keyPressed(KeyEvent evt) { // When a key is pressed, trigger this method

        int key = evt.getKeyCode();  // Keyboard code for the key that was pressed

        switch (key) { // Chanes the colour of the cube based on the key pressed

            case KeyEvent.VK_Q: // If key is Q, change colour to red and repaint gameGUI

                DrawShapes.colour = Color.RED;

                gameGUI.repaint();

                break;

            case KeyEvent.VK_W:  // If key is W, change colour to green and repaint gameGUI

                DrawShapes.colour = new Color(0, 153, 102);

                gameGUI.repaint();

                break;

            case KeyEvent.VK_E: // If key is E, change colour to blue and repaint gameGUI

                DrawShapes.colour = Color.BLUE;

                gameGUI.repaint();

                break;

            default: // If it is not any of these, do nothing

                break;
        }

    }

    @Override
    public void keyTyped(KeyEvent e) {

        // Required to use KeyListener
    }

    @Override
    public void keyReleased(KeyEvent e) {

        // Required to use KeyListener
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JDialog gameOverScreen;
    private javax.swing.JLabel gameOverTitle;
    private javax.swing.JTextArea highscores;
    private javax.swing.JLabel howTo1;
    private javax.swing.JLabel howTo2;
    private javax.swing.JTextField nameIn;
    private javax.swing.JLabel namePrompt;
    private javax.swing.JButton ok;
    private javax.swing.JButton play;
    private javax.swing.JLabel score;
    private javax.swing.JLabel scorePrompt;
    private javax.swing.JScrollPane scoreScrollPane;
    private javax.swing.JPanel startScreen;
    private javax.swing.JLabel title;
    // End of variables declaration//GEN-END:variables

    @Override
    public void mouseClicked(MouseEvent e) {

        // Required to use MouseListener
    }

    @Override
    public void mousePressed(MouseEvent e) { // Used to focus input on gameGUI

        // Request that the input focus be given to the gameGUI
        gameGUI.requestFocus();

    }

    @Override
    public void mouseReleased(MouseEvent e) {

        // Required to use MouseListener
    }

    @Override
    public void mouseEntered(MouseEvent e) {

        // Required to use MouseListener
    }

    @Override
    public void mouseExited(MouseEvent e) {

        // Required to use MouseListener
    }
}
